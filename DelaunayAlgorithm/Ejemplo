Point2D(300,100),Point2D(300,200),Point2D(400,100),Point2D(400,200)

def flipEdge(triangle1,triangle2,edge):
    pointP = triangle1.getThirdPoint(edge)
    pointQ = triangle2.getThirdPoint(edge)

    #print "triangulo 1 antes" + str(triangle1)
    #print "triangulo 2 antes" + str(triangle2)
    #print ""

    #print map(lambda x: str(x),triangle2.getNeighbours())

    #Guardar los vecinos originales, antes de cambiar los vertices de los triangulos
    n1T1 = triangle1.getNeighbourFromEdge(Edge(edge.p2,pointP))
    n1T1Neighbours = n1T1.getNeighbours()

    #print "vecinos antes de puntos"
    #print map(lambda x: str(x),n1T1.getNeighbours())

    n2T1 = triangle1.getNeighbourFromEdge(Edge(pointP,edge.p1))
    n2T1Neighbours = n2T1.getNeighbours()

    n1T2 = triangle2.getNeighbourFromEdge(Edge(edge.p1,pointQ))
    n1T2Neighbours = n1T2.getNeighbours()

    n2T2 = triangle2.getNeighbourFromEdge(Edge(pointQ,edge.p2))
    n2T2Neighbours = n2T2.getNeighbours()

    triangle1.setPoints(pointP,edge.p1,pointQ)
    triangle2.setPoints(pointP,pointQ,edge.p2)

    print "vecinos despues de puntos"
    print map(lambda x: str(x),n1T1.getNeighbours())


    print "triangulo 1 despues" + str(triangle1)
    print "triangulo 2 despues" + str(triangle2)
    print ""

    triangle1.setNeighbours(n2T1,n1T2,triangle2)
    triangle2.setNeighbours(n2T2,n1T1,triangle1)

    print "vecinos despues de setneighbours"
    print map(lambda x: str(x),n1T1.getNeighbours())


    print map(lambda x: str(x),triangle1.getNeighbours())
    print map(lambda x: str(x),triangle2.getNeighbours())

    #Notificar a los vecinos que ha cambiado quien esta junto a el.
    if n1T1 is not None:
        print "n1T1" + str(n1T1)
        print str(Edge(edge.p2,pointP))
        print "vecinos antes"
        print map(lambda x: str(x),n1T1.getNeighbours())
        n1T1.setNeighbourByEdge(Edge(edge.p2,pointP),triangle2)
        print "vecinos despues"
        print map(lambda x: str(x),n1T1.getNeighbours())

    if n2T1 is not None:
        print "n2T1" + str(n2T1)
        print "vecinos antes"
        print map(lambda x: str(x),n2T1.getNeighbours())
        n2T1.setNeighbourByEdge(Edge(pointP,edge.p1),triangle1)
        print "vecinos despues"
        print map(lambda x: str(x),n2T1.getNeighbours())

    if n1T2 is not None:
        print "n1T2" + str(n1T2)
        print "vecinos antes"
        print map(lambda x: str(x),n1T2.getNeighbours())
        n1T2.setNeighbourByEdge(Edge(edge.p1,pointQ),triangle1)
        print "vecinos despues"
        print map(lambda x: str(x),n1T2.getNeighbours())

    if n2T2 is not None:
        print "n2T2" + str(n2T2)
        print "vecinos antes"
        print map(lambda x: str(x),n2T2.getNeighbours())
        n2T2.setNeighbourByEdge(Edge(pointQ,edge.p2),triangle2)
        print "vecinos despues"
        print map(lambda x: str(x),n2T2.getNeighbours())

    return Edge(pointP,pointQ)




    def bigTriangle(pointList,perc):
    #Encargado de devolver los tres puntos que forman el triangulo inicial del algoritmo
    (up,down,right,left) = findCorners(pointList)

    x1 = right*1.5
    y1 = up*1.5

    x2 = left*0.6
    y2 = down*0.6

    leftUpPoint = Point2D(x2 - (x1 - x2)*perc, y1)
    rightUpPoint = Point2D(x1 + (x1 - x2)*perc, y1)

    upXCoord = (rightUpPoint.getX() - leftUpPoint.getX())/2
    slope = (y1 - y2)/(leftUpPoint.getX() - x2)

    downPoint = Point2D(upXCoord, y1 + slope*(upXCoord - leftUpPoint.getX()))

    return Triangle(downPoint,leftUpPoint,rightUpPoint)


    def bigTriangle(pointList,perc):
    #Encargado de devolver los tres puntos que forman el triangulo inicial del algoritmo
    (up,down,right,left) = findCorners(pointList)

    x1 = right*1.5
    y1 = up*1.5

    x2 = left*0.6
    y2 = down*0.6

    p1 = Point2D(x1,y1)
    p2 = Point2D(x1,y2)
    p3 = Point2D(x2,y2)
    p4 = Point2D(x2,y1)

    t1 = Triangle(p1,p4,p3)
    t2 = Triangle(p1,p3,p2)

    t1.setNeighbours(t2,None,None)
    t2.setNeighbours(None,None,t1)

    return [t1,t2]
